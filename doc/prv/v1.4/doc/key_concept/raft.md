# The Ordering Service - Raft

하이퍼레저 패브릭에서 Raft는 leader-follower 모델을 사용한다. 
- leader-follower 모델: consenter set이라는 채널 별 노드의 집합에서 동적으로 리더를 선출하고, 리더는 팔로워노드에게 메시지를 복제한다.

이러한 시스템은 과반수 이상의 오더러 노드(Quorum, 쿼럼)가 존재하는 경우 CFT를 유지할 수 있도록 하는데, 예를 들어 3개의 오더러가 있을 경우 1개, 5개의 오더러가 있을 경우 2개의 오더러에 장애가 발생해도 시스템은 유지된다.
- CFT(Crash Fault Tolerant)
  - 일부 시스템 구성 요소들이 작동하지 않더라도 올바른 합의에 도달할 수 있는 성질을 말한다. 기존 퍼블릭 블록체인에서 주로 사용되는 BFT(Byzantine fault tolerance) 시스템은 시스템 구성요소의 기능적 문제뿐 아니라 악의적인 공격(Malicious attack)까지 고려하므로 CFT 시스템과 비교했을 때 더욱 복잡하며 느리다.
  - Raft, Kafka에서 사용된다.
  - 출처: https://medium.com/decipher-media/%ED%95%98%EC%9D%B4%ED%8D%BC%EB%A0%88%EC%A0%80-%ED%8C%A8%EB%B8%8C%EB%A6%AD-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EA%B5%AC%EC%A1%B0-hyperledger-fabric-network-structure-d7fd9c759983

<br>

## Kafka-Zookeeper(kz)와 비교한 Raft

1. kz보다 관리요소가 매우 적다. 오더러 자체에서 모두 커버 가능하다.
2. kz는 org별로 구성되어야 해서, 서로 다른 org에서 오더러를 호출할 경우 분산환경의 이점을 갖기 어렵다. 
3. kz는 별도로 사용법을 배우고 구축해야하지만, raft는 패브릭 내에서 기본 제공된다.
4. kz는 서버 풀(broker)이 존재하고, 오더러 조직에서는 채널당 몇개의 오더러를 사용할지 명시해야 한다(중앙 관리형태). 
    - Raft는 유저가 직접 채널 당 오더러를 설정할 수 있으며, 피어 조직에 오더러를 포함시킬 수도 있다. 

<br>

## Raft 개념

- Log entry

  - Raft 오더링 서비스의 기본 작업 단위. 이를 묶어 로그(log)가 된다.
  - 구성원의 과반수(쿼럼)가 항목(entry)과 순서(order)에 동의하면, 다른 오더러에게 해당 로그를 복제한다.

- Consenter set
  - 오더러는 채널의 합의 매커니즘에 적극적으로 참여하고 복제 로그를 수집한다.

- FSM(Finite-State Machine)
  - 오더러 노드의 로그 시퀀스가 동일한 순서로 작성되었는지 확인한다.

- Quorum
  - 트랜잭션 오더링을 위한 가장 최소한의 오더러 갯수, 즉 전체에서 과반 수 이상의 오더러를 의미한다.
  - 쿼럼을 만족하지 못하면, 채널에서 읽기 및 쓰기 작업과 새로운 로그 커밋이 불가능하다.

- Leader / Follower
  - 리더는 새로운 로그 항목을 수집하고, 이를 팔로워에게 복제하여 로그가 전체적으로 일관되게 유지시킨다.
  - 리더는 heartbeat 메시지를 통해 팔로워 노드와 계속 연결하는데, 리더로부터 해당 메시지 전송이 중단되면 팔로워 중 하나가 새로운 리더로 선출된다.

<br>

## Raft in a transaction flow

모든 Raft 노드는 시스템 채널에 포함되어야 하지만, 응용 프로그램 채널은 선택적으로 포함될 수 있다.
각 채널에서는 오더러를 선택적으로 구성할 수 있으며, 필요에 따라 하나의 노드를 추가 또는 삭제도 가능하다.

Raft에서 트랜잭션은 이를 수신하는 오더러 노드에 의해 채널 별 리더로 자동 라우팅된다. 그러므로 피어와 응용프로그램은 리더 노드에 대한 정보를 알 필요가 없으며, 오더러 노드가 모두 관리한다.

오더러의 유효 검사(validation)가 완료되면, 트랜잭션이 순서대로 정렬 -> 블록으로 패키징 -> consent(동의과정) -> 분배된다.

<br>

## Architectural notes

### How leader election works in Raft

리더 선출 과정은 오더러 내부에서 진행된다.  
Raft로 구성된 노드는 팔로워(follower), 후보(candidate), 리더(leader) 중 하나의 상태를 갖는다.  
- 팔로워
  - 모든 노드는 처음에 팔로워로 시작한다.
  - 이 상태에서는 리더로 선출된 노드로부터 로그 항목을 받거나 리더 선출 과정에 투표할 수 있다. 
- 후보
  - 팔로워 노드가 특정 시간동안 리더로부터 하트비트(heartbeat) 메시지를 수신하지 않으면, 자동으로 후보로 승격된다.
  - 후보 상태의 노드는 다른 노드의 투표를 요청하고, 이 때 과반수(quorum)이상의 투표를 받으면 리더로 승격된다.
- 리더
  - 새로운 로그 항목들을 승인하고, 이를 팔로워에게 복제한다.

이를 시각적으로 확인하려면 [링크](http://thesecretlivesofdata.com/raft/)를 참조한다.

### Snapshots

오더러 서비스가 갑자기 중단되었다가 다시 시작하게 될 경우, 누락된 로그 항목을 관리하는 방법이다.  
스냅샷은 디스크 공간을 절약하기 위해 Raft에서 사용하는 방법으로, 사용자가 로그에 보관할 데이터의 바이트 수(블록)를 정의할 수 있다. 

예로 들어, 복제본 R1이 중단되었다가 재연결되었다고 가정한다. R1의 최신 블록은 100번이고, 리더 L은 196번 블록에 있다. 스냅샷으로 구성할 데이터 크기가 20인 경우, R1은 L로부터 180번 블록을 받고, 101부터 180 사이의 블록들을 요청할 것이다. 그리고 180부터 196까지의 블록은 정상적인 Raft 프로토콜로 복제될 것이다.
